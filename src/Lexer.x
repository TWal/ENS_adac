{
module Lexer (runAlex', alexMonadScan', alexError', Alex, scanner) where
import Control.Monad (liftM)
}

%wrapper "monadUserState"

$digit = 0-9
$alpha = [a-zA-Z]

tokens :-
    $white+                         ;
    "--".*                          ;
    $digit+                         { tok_read TokenInt }
    \' . \'                         { tok' $ TokenChar . head . tail }
    -- reserved words
    "access"                        { tok TokenAccess }
    "false"                         { tok TokenFalse }
    "loop"                          { tok TokenLoop }
    "procedure"                     { tok TokenProcedure }
    "true"                          { tok TokenTrue }
    "and"                           { tok TokenAnd }
    "for"                           { tok TokenFor }
    "new"                           { tok TokenNew }
    "record"                        { tok TokenRecord }
    "type"                          { tok TokenType }
    "begin"                         { tok TokenBegin }
    "function"                      { tok TokenFunction }
    "not"                           { tok TokenNot }
    --"rem"                           { tok TokenRem }
    "use"                           { tok TokenUse }
    "else"                          { tok TokenElse }
    "if"                            { tok TokenIf }
    "null"                          { tok TokenNull }
    "return"                        { tok TokenReturn }
    "while"                         { tok TokenWhile }
    "elsif"                         { tok TokenElsif }
    "in"                            { tok TokenIn }
    "or"                            { tok TokenOr }
    "reverse"                       { tok TokenReverse }
    "with"                          { tok TokenWith }
    "end"                           { tok TokenEnd }
    "is"                            { tok TokenIs }
    "out"                           { tok TokenOut }
    "then"                          { tok TokenThen }
    -- operations
    "="                             { tok TokenEqual }
    "/="                            { tok TokenNotEqual }
    "<"                             { tok TokenLower }
    "<="                            { tok TokenLowerEqual }
    ">"                             { tok TokenGreater }
    ">="                            { tok TokenGreaterEqual }
    "+"                             { tok TokenAdd }
    "-"                             { tok TokenSubtract }
    "*"                             { tok TokenMultiply }
    "("                             { tok TokenLParent }
    ")"                             { tok TokenRParent }
    "rem"                           { tok TokenRem }
    -- Some other characters 
    ":="                            { tok TokenAssign }
    ";"                             { tok TokenSemicolon }
    "."                             { tok TokenDot }
    ":"                             { tok TokenColon }
    -- identifier
    $alpha [$alpha $digit \_ ]*     { tok_string TokenIdent }

{

--tok' :: (String -> TokenClass) -> AlexInput -> Int64 -> Alex Token
tok' :: (String -> TokenClass) -> AlexAction Token
tok' f (p,_,_,s) i = return $ Token p (f (take i s))

tok :: TokenClass -> AlexAction Token
tok x = tok' (const x)

tok_read :: (Integer -> TokenClass) -> AlexAction Token
tok_read x = tok' $ \s -> x (read s)

tok_string :: (String -> TokenClass) -> AlexAction Token
tok_string x = tok' $ \s -> x s

alexEOF :: Alex Token
alexEOF = do
  (p, _, _, _) <- alexGetInput
  return $ Token p TokenEOF

scanner :: String -> FilePath -> Either String [Token]
scanner str fp =
    let loop = do
                t <- alexMonadScan'
                let (Token _ cl) = t
                if cl == TokenEOF then return [t]
                else do
                        toks <- loop
                        return (t : toks)
    in runAlex' str fp loop

data AlexUserState = AlexUserState FilePath

alexInitUserState :: AlexUserState
alexInitUserState = AlexUserState "<unknown>"

-- almost identical to the one generated by alex
alexMonadScan' :: Alex Token
alexMonadScan' = do
  inp <- alexGetInput
  sc <- alexGetStartCode
  case alexScan inp sc of
    AlexEOF -> alexEOF
    AlexError (p,_,_,s) -> alexError' p $ "lexical error at character '" ++ take 1 s ++ "'" --line changed
    AlexSkip  inp' _len -> do
        alexSetInput inp'
        alexMonadScan' --line changed
    AlexToken inp' len action -> do
        alexSetInput inp'
        action (ignorePendingBytes inp) len

setFilePath :: FilePath -> Alex ()
setFilePath fp = alexSetUserState $ AlexUserState fp

getFilePath :: Alex FilePath
getFilePath = liftM (\(AlexUserState fp) -> fp) alexGetUserState

runAlex' :: String -> FilePath -> Alex a -> Either String a
runAlex' s fp a = runAlex s $
    do setFilePath fp
       a

alexError' :: AlexPosn -> String -> Alex a
alexError' (AlexPn _ l c) msg =
    do
      fp <- getFilePath
      alexError ("File \"" ++ fp ++ "\", line " ++ show l ++ ", characters " ++ show c ++ "-" ++ show (c+1)
          ++ ":\n" ++ msg)

data Token = Token AlexPosn TokenClass deriving (Eq, Show)

data TokenClass =
      TokenInt Integer
    | TokenIdent String
    | TokenChar Char
    | TokenAccess
    | TokenFalse
    | TokenLoop
    | TokenProcedure
    | TokenTrue
    | TokenAnd
    | TokenFor
    | TokenNew
    | TokenRecord
    | TokenType
    | TokenBegin
    | TokenFunction
    | TokenNot
    | TokenUse
    | TokenElse
    | TokenIf
    | TokenNull
    | TokenReturn
    | TokenWhile
    | TokenElsif
    | TokenIn
    | TokenOr
    | TokenReverse
    | TokenWith
    | TokenEnd
    | TokenIs
    | TokenOut
    | TokenThen
    | TokenEqual
    | TokenNotEqual
    | TokenLower
    | TokenLowerEqual
    | TokenGreater
    | TokenGreaterEqual
    | TokenAdd
    | TokenSubtract
    | TokenMultiply
    | TokenLParent
    | TokenRParent
    | TokenRem
    | TokenAssign
    | TokenSemicolon
    | TokenDot
    | TokenColon
    | TokenEOF
    deriving (Eq, Show)

}
