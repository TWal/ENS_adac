{
module Lexer (
    runAlex',
    alexMonadScan',
    alexError',
    scanner,
    Alex,
    Position(..),
    AlexPosn(..),
    Token(..)
) where

import Control.Monad (liftM)
import Data.Char (toLower)
}

%wrapper "monadUserState"

$digit = 0-9
$alpha = [a-zA-Z]

tokens :-
    $white+                         ;
    "--".*                          ;
    $digit+                         { tok_read TokenInt }
    \' . \'                         { tok_char TokenChar }
    -- reserved words
    "access"                        { tok TokenAccess }
    "false"                         { tok TokenFalse }
    "loop"                          { tok TokenLoop }
    "procedure"                     { tok TokenProcedure }
    "true"                          { tok TokenTrue }
    "and"                           { tok TokenAnd }
    "for"                           { tok TokenFor }
    "new"                           { tok TokenNew }
    "record"                        { tok TokenRecord }
    "type"                          { tok TokenType }
    "begin"                         { tok TokenBegin }
    "function"                      { tok TokenFunction }
    "not"                           { tok TokenNot }
    --"rem"                           { tok TokenRem }
    "use"                           { tok TokenUse }
    "else"                          { tok TokenElse }
    "if"                            { tok TokenIf }
    "null"                          { tok TokenNull }
    "return"                        { tok TokenReturn }
    "while"                         { tok TokenWhile }
    "elsif"                         { tok TokenElsif }
    "in"                            { tok TokenIn }
    "or"                            { tok TokenOr }
    "reverse"                       { tok TokenReverse }
    "with"                          { tok TokenWith }
    "end"                           { tok TokenEnd }
    "is"                            { tok TokenIs }
    "out"                           { tok TokenOut }
    "then"                          { tok TokenThen }
    -- operations
    "="                             { tok TokenEqual }
    "/="                            { tok TokenNotEqual }
    "<"                             { tok TokenLower }
    "<="                            { tok TokenLowerEqual }
    ">"                             { tok TokenGreater }
    ">="                            { tok TokenGreaterEqual }
    "+"                             { tok TokenAdd }
    "-"                             { tok TokenSubtract }
    "*"                             { tok TokenMultiply }
    "/"                             { tok TokenDivide }
    "("                             { tok TokenLParent }
    ")"                             { tok TokenRParent }
    "rem"                           { tok TokenRem }
    -- Some other characters
    ":="                            { tok TokenAssign }
    ";"                             { tok TokenSemicolon }
    "."                             { tok TokenDot }
    ":"                             { tok TokenColon }
    ","                             { tok TokenComma }
    ".."                            { tok TokenDoubledot }
    "character'val"                 { tok TokenCharval }
    -- identifier
    $alpha [$alpha $digit \_ ]*     { tok_string TokenIdent }

{

tok' :: (Position -> String -> Token) -> AlexAction Token
tok' f (p,_,_,s) i = getFilePath >>= (\fp -> return $ (f (Position p fp) (take i s)))

tok :: (Position -> Token) -> AlexAction Token
tok x = tok' $ \p _ -> x p

tok_read :: ((Position, Integer) -> Token) -> AlexAction Token
tok_read x = tok' $ \p s -> x (p, (read s))

tok_string :: ((Position, String) -> Token) -> AlexAction Token
tok_string x = tok' $ \p s -> x (p, s)

tok_char :: ((Position, Char) -> Token) -> AlexAction Token
tok_char x = tok' $ \p s -> x (p, (head . tail $ s))

alexEOF :: Alex Token
alexEOF = do
  (p, _, _, _) <- alexGetInput
  fp <- getFilePath
  return $ TokenEOF (Position p fp)

scanner :: String -> FilePath -> Either String [Token]
scanner str fp =
    let loop = do
                t <- alexMonadScan'
                case t of
                  TokenEOF _ -> return [t]
                  _ -> do
                        toks <- loop
                        return (t : toks)
    in runAlex' str fp loop

data AlexUserState = AlexUserState FilePath

alexInitUserState :: AlexUserState
alexInitUserState = AlexUserState "<unknown>"

-- almost identical to the one generated by alex
alexMonadScan' :: Alex Token
alexMonadScan' = do
  (pos, pc, b, str)  <- alexGetInput
  let inp = (pos, pc, b, map toLower str)
  sc <- alexGetStartCode
  case alexScan inp sc of
    AlexEOF -> alexEOF
    AlexError (_,_,_,s) -> alexError' $ "lexical error at character '" ++ take 1 s ++ "'" --line changed
    AlexSkip  inp' _len -> do
        alexSetInput inp'
        alexMonadScan' --line changed
    AlexToken inp' len action -> do
        alexSetInput inp'
        action (ignorePendingBytes inp) len

setFilePath :: FilePath -> Alex ()
setFilePath fp = alexSetUserState $ AlexUserState fp

getFilePath :: Alex FilePath
getFilePath = liftM (\(AlexUserState fp) -> fp) alexGetUserState

runAlex' :: String -> FilePath -> Alex a -> Either String a
runAlex' s fp a = runAlex s $
    do setFilePath fp
       a

alexError' :: String -> Alex a
alexError' msg =
    do
      fp <- getFilePath
      ((AlexPn _ l c), _, _, _) <- alexGetInput
      alexError ("File \"" ++ fp ++ "\", line " ++ show l ++ ", characters " ++ show c ++ "-" ++ show (c+1)
          ++ ":\n" ++ msg)

data Position = Position AlexPosn FilePath deriving (Eq, Show)

data Token =
      TokenInt (Position, Integer)
    | TokenIdent (Position, String)
    | TokenChar (Position, Char)
    | TokenAccess Position
    | TokenFalse Position
    | TokenLoop Position
    | TokenProcedure Position
    | TokenTrue Position
    | TokenAnd Position
    | TokenFor Position
    | TokenNew Position
    | TokenRecord Position
    | TokenType Position
    | TokenBegin Position
    | TokenFunction Position
    | TokenNot Position
    | TokenUse Position
    | TokenElse Position
    | TokenIf Position
    | TokenNull Position
    | TokenReturn Position
    | TokenWhile Position
    | TokenElsif Position
    | TokenIn Position
    | TokenOr Position
    | TokenReverse Position
    | TokenWith Position
    | TokenEnd Position
    | TokenIs Position
    | TokenOut Position
    | TokenThen Position
    | TokenEqual Position
    | TokenNotEqual Position
    | TokenLower Position
    | TokenLowerEqual Position
    | TokenGreater Position
    | TokenGreaterEqual Position
    | TokenAdd Position
    | TokenSubtract Position
    | TokenMultiply Position
    | TokenDivide Position
    | TokenLParent Position
    | TokenRParent Position
    | TokenRem Position
    | TokenAssign Position
    | TokenSemicolon Position
    | TokenDot Position
    | TokenColon Position
    | TokenComma Position
    | TokenDoubledot Position
    | TokenCharval Position
    | TokenEOF Position
    deriving (Eq, Show)

}
