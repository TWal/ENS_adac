{
module Lexer (
    runAlex',
    alexMonadScan',
    alexError',
    scanner,
    Alex,
    AlexPosn,
    Token(..)
) where

import Control.Monad (liftM)
}

%wrapper "monadUserState"

$digit = 0-9
$alpha = [a-zA-Z]

tokens :-
    $white+                         ;
    "--".*                          ;
    $digit+                         { tok_read TokenInt }
    \' . \'                         { tok_char TokenChar }
    -- reserved words
    "access"                        { tok TokenAccess }
    "false"                         { tok TokenFalse }
    "loop"                          { tok TokenLoop }
    "procedure"                     { tok TokenProcedure }
    "true"                          { tok TokenTrue }
    "and"                           { tok TokenAnd }
    "for"                           { tok TokenFor }
    "new"                           { tok TokenNew }
    "record"                        { tok TokenRecord }
    "type"                          { tok TokenType }
    "begin"                         { tok TokenBegin }
    "function"                      { tok TokenFunction }
    "not"                           { tok TokenNot }
    --"rem"                           { tok TokenRem }
    "use"                           { tok TokenUse }
    "else"                          { tok TokenElse }
    "if"                            { tok TokenIf }
    "null"                          { tok TokenNull }
    "return"                        { tok TokenReturn }
    "while"                         { tok TokenWhile }
    "elsif"                         { tok TokenElsif }
    "in"                            { tok TokenIn }
    "or"                            { tok TokenOr }
    "reverse"                       { tok TokenReverse }
    "with"                          { tok TokenWith }
    "end"                           { tok TokenEnd }
    "is"                            { tok TokenIs }
    "out"                           { tok TokenOut }
    "then"                          { tok TokenThen }
    -- operations
    "="                             { tok TokenEqual }
    "/="                            { tok TokenNotEqual }
    "<"                             { tok TokenLower }
    "<="                            { tok TokenLowerEqual }
    ">"                             { tok TokenGreater }
    ">="                            { tok TokenGreaterEqual }
    "+"                             { tok TokenAdd }
    "-"                             { tok TokenSubtract }
    "*"                             { tok TokenMultiply }
    "/"                             { tok TokenDivide }
    "("                             { tok TokenLParent }
    ")"                             { tok TokenRParent }
    "rem"                           { tok TokenRem }
    -- Some other characters
    ":="                            { tok TokenAssign }
    ";"                             { tok TokenSemicolon }
    "."                             { tok TokenDot }
    ":"                             { tok TokenColon }
    ","                             { tok TokenComma }
    -- identifier
    $alpha [$alpha $digit \_ ]*     { tok_string TokenIdent }

{

tok' :: (AlexPosn -> String -> Token) -> AlexAction Token
tok' f (p,_,_,s) i = return $ (f p (take i s))

tok :: (AlexPosn -> Token) -> AlexAction Token
tok x = tok' $ \p _ -> x p

tok_read :: ((AlexPosn, Integer) -> Token) -> AlexAction Token
tok_read x = tok' $ \p s -> x (p, (read s))

tok_string :: ((AlexPosn, String) -> Token) -> AlexAction Token
tok_string x = tok' $ \p s -> x (p, s)

tok_char :: ((AlexPosn, Char) -> Token) -> AlexAction Token
tok_char x = tok' $ \p s -> x (p, (head . tail $ s))

alexEOF :: Alex Token
alexEOF = do
  (p, _, _, _) <- alexGetInput
  return $ TokenEOF p

scanner :: String -> FilePath -> Either String [Token]
scanner str fp =
    let loop = do
                t <- alexMonadScan'
                case t of
                  TokenEOF _ -> return [t]
                  _ -> do
                        toks <- loop
                        return (t : toks)
    in runAlex' str fp loop

data AlexUserState = AlexUserState FilePath

alexInitUserState :: AlexUserState
alexInitUserState = AlexUserState "<unknown>"

-- almost identical to the one generated by alex
alexMonadScan' :: Alex Token
alexMonadScan' = do
  inp <- alexGetInput
  sc <- alexGetStartCode
  case alexScan inp sc of
    AlexEOF -> alexEOF
    AlexError (_,_,_,s) -> alexError' $ "lexical error at character '" ++ take 1 s ++ "'" --line changed
    AlexSkip  inp' _len -> do
        alexSetInput inp'
        alexMonadScan' --line changed
    AlexToken inp' len action -> do
        alexSetInput inp'
        action (ignorePendingBytes inp) len

setFilePath :: FilePath -> Alex ()
setFilePath fp = alexSetUserState $ AlexUserState fp

getFilePath :: Alex FilePath
getFilePath = liftM (\(AlexUserState fp) -> fp) alexGetUserState

runAlex' :: String -> FilePath -> Alex a -> Either String a
runAlex' s fp a = runAlex s $
    do setFilePath fp
       a

alexError' :: String -> Alex a
alexError' msg =
    do
      fp <- getFilePath
      ((AlexPn _ l c), _, _, _) <- alexGetInput
      alexError ("File \"" ++ fp ++ "\", line " ++ show l ++ ", characters " ++ show c ++ "-" ++ show (c+1)
          ++ ":\n" ++ msg)

data Token =
      TokenInt (AlexPosn, Integer)
    | TokenIdent (AlexPosn, String)
    | TokenChar (AlexPosn, Char)
    | TokenAccess AlexPosn
    | TokenFalse AlexPosn
    | TokenLoop AlexPosn
    | TokenProcedure AlexPosn
    | TokenTrue AlexPosn
    | TokenAnd AlexPosn
    | TokenFor AlexPosn
    | TokenNew AlexPosn
    | TokenRecord AlexPosn
    | TokenType AlexPosn
    | TokenBegin AlexPosn
    | TokenFunction AlexPosn
    | TokenNot AlexPosn
    | TokenUse AlexPosn
    | TokenElse AlexPosn
    | TokenIf AlexPosn
    | TokenNull AlexPosn
    | TokenReturn AlexPosn
    | TokenWhile AlexPosn
    | TokenElsif AlexPosn
    | TokenIn AlexPosn
    | TokenOr AlexPosn
    | TokenReverse AlexPosn
    | TokenWith AlexPosn
    | TokenEnd AlexPosn
    | TokenIs AlexPosn
    | TokenOut AlexPosn
    | TokenThen AlexPosn
    | TokenEqual AlexPosn
    | TokenNotEqual AlexPosn
    | TokenLower AlexPosn
    | TokenLowerEqual AlexPosn
    | TokenGreater AlexPosn
    | TokenGreaterEqual AlexPosn
    | TokenAdd AlexPosn
    | TokenSubtract AlexPosn
    | TokenMultiply AlexPosn
    | TokenDivide AlexPosn
    | TokenLParent AlexPosn
    | TokenRParent AlexPosn
    | TokenRem AlexPosn
    | TokenAssign AlexPosn
    | TokenSemicolon AlexPosn
    | TokenDot AlexPosn
    | TokenColon AlexPosn
    | TokenComma AlexPosn
    | TokenEOF AlexPosn
    deriving (Eq, Show)

}
